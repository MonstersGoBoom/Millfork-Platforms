//https://patpend.net/technical/tg16/vdcdox.txt

const byte VDC_MAWR	=0 
const byte VDC_MARR	=1 
const byte VDC_VRR	=2 
const byte VDC_VWR 	=3
const byte VDC_CR 	=5 
const byte VDC_RCR 	=6 
const byte VDC_BXR 	=7 
const byte VDC_BYR 	=8 
const byte VDC_MWR 	=9 
const byte VDC_HSR 	=10 
const byte VDC_HDR	=11
const byte VDC_VPR 	=12
const byte VDC_VDW 	=13 
const byte VDC_VCR 	=14 
const byte VDC_DCR 	=15 

const word VDP_SPR_COLLISION_ENABLE = %0000000000000001
const word VDP_SPR_OVERFLOW_IRQ 		= %0000000000000010
const word VDP_RCR_ENABLE				 		= %0000000000000100
const word VDP_IRQ_ENABLE				 		= %0000000000001000
const word VDP_SPR_ENABLE				 		= %0000000001000000
const word VDP_BG_ENABLE				 		= %0000000010000000

volatile byte	VDC_status	@$0100
volatile byte	VDC_data_l	@$0102
volatile byte	VDC_data_h	@$0103
//volatile word	VDC_DATA_w  @$0102
volatile byte irqport @$1400
volatile byte irq_disable @$1402
volatile byte irq_status @$1403

volatile byte VCE_ADDRESS_l  @$0402
volatile byte VCE_ADDRESS_h  @$0403
volatile byte VCE_DATA_l     @$0404
volatile byte VCE_DATA_h     @$0405
volatile word VCE_DATA_w	   @$0404

macro asm void PCE_init() {
  sei	;	disable IRQ
  csh ;	Change Speed High
  cld ; Clear Decimal Flag
	stz $0c00
  lda #$ff 				; hardware 	$0000-$1fff
  tam #%00000001 
  lda #$f8 				;	ram 			$2000-$3fff
  tam #%00000010 
  lda #1					;	prgrom1		$4000-$5fff 
  tam #%00000100
  lda #2					;	prgrom2		$6000-$7fff
  tam #%00001000 
  lda #3					;	prgrom3		$8000-$afff
  tam #%00010000 
  lda #4					;	prgrom4		$c000-$dfff 
  tam #%00100000 
  ;
  ;	not needed as it's default value is 0 
  ;
  lda #0					;	prgrom0	$e000-$ffff 
  tam #%01000000 

	lda #$7
	sta $1402
	stz $1403

	

}
//	set the VDC register reg, with value 

macro asm void enable_irq()
{

	lda #%00000001 
	sta irq_disable
	stz irq_status
	cli
}

volatile byte framesync 

volatile byte vsr
//	not correct but working ?

void PCE_vdc_irq()
{
	asm {
   	pha
    phx
    phy
	  lda VDC_status
		sta vsr
		and #$2 
		beq vsynccheck
		stz $106
		stz $106

vsynccheck:
		lda vsr
		and #$20
		beq exit
		inc	framesync 
exit:	
		lda #$00 
		sta VDC_status

    ply
    plx
    pla
irq2:
    rti
	}	
}

void PCE_timer_irq()
{
	asm 
	{
		sta $1403	;ACK TIMER
		stz $0c01	;Turn off timer
		rti
	}
}


void WaitVSync()
{
//	while (framesync!=0){}
}


macro asm void VREG(byte const reg,word const value) {
  st0 #(reg)	
  st1 #lo(value)
  st2 #hi(value)
}

//	send one word of data
inline asm void VWRITE(word value) {
  st0 #2
  lda lo(value)
  sta $102
  lda hi(value)
  sta $103
  ? rts
}

//	send many words 
//	removes need to write address and write flag 
void VDC_UPLOAD(word dest,pointer source,word size)
{
word z
  asm 
  {
    st0 #0
  }
  VDC_data_l = lo(dest)
  VDC_data_h = hi(dest)

  asm 
  {
    st0 #2
  }

  z=$4000
  size+=$4000
  while (z<size)
  {
    VDC_data_l = source[z]
    z+=1
    VDC_data_h = source[z]
    z+=1
  }
}

//	upload the palette
void VCE_UPLOAD(byte index,byte number,pointer source)
{
word z,e
  z=index 
  z<<=4
  z.hi|=$40
  e = number+1
  e<<=4 
  e+= z
  VCE_ADDRESS_l = lo(z)
  VCE_ADDRESS_h = hi(z)
  while (z<e)
  {
    VCE_DATA_l = source[z]
    z+=1
    VCE_DATA_h = source[z]
    z+=1
  }
}

const array irq_vector @$FFF8 = @word [PCE_vdc_irq.addr]
const array timer_vector @$FFFa = @word [PCE_timer_irq.addr]
const array reset_vector @$FFFE = @word [main.addr]

